================================================================================
CORRECCIONES RECOMENDADAS PARA EL FRONTEND - ROL RESPONSABLE
================================================================================
Fecha: 5 de diciembre de 2025
Basado en: frontend_responsable.txt

================================================================================
1. INCONSISTENCIA DE ESTADOS (CRÍTICO)
================================================================================

PROBLEMA:
El frontend compara estados en minúsculas en algunas vistas y en mayúsculas 
en otras (especialmente MisTareasClient.tsx).

VISTAS AFECTADAS:
- MisTareasClient.tsx usa: "ENVIADO", "APROBADO", "REQUIERE_CORRECCION"
- Resto de vistas usan: "enviado_a_tiempo", "enviado_tarde", "aprobado"

CORRECCIÓN:
Normalizar TODOS los estados a un solo formato. Opciones:
a) Convertir siempre a minúsculas: estado.toLowerCase()
b) Convertir siempre a mayúsculas: estado.toUpperCase()
c) Usar una función de normalización centralizada

EJEMPLO DE CORRECCIÓN en MisTareasClient.tsx:
```typescript
// ANTES (incorrecto)
const esCompletada = (periodo) => 
  periodo.estado === "ENVIADO" || periodo.estado === "APROBADO";

// DESPUÉS (correcto)
const esCompletada = (periodo) => {
  const estado = periodo.estado?.toLowerCase();
  return estado === "enviado_a_tiempo" || 
         estado === "enviado_tarde" || 
         estado === "aprobado";
};
```

================================================================================
2. ALERTAS NO PERSISTEN (FUNCIONALIDAD INCOMPLETA)
================================================================================

PROBLEMA:
Las alertas marcadas como "leídas" se pierden al recargar la página.
No existe integración con backend para persistir este estado.

CORRECCIÓN TEMPORAL (localStorage):
```typescript
// Guardar estado en localStorage
const marcarComoLeida = (alertaId: string) => {
  const leidasGuardadas = JSON.parse(localStorage.getItem('alertasLeidas') || '[]');
  leidasGuardadas.push(alertaId);
  localStorage.setItem('alertasLeidas', JSON.stringify(leidasGuardadas));
  // Actualizar estado React
};

// Recuperar al cargar
useEffect(() => {
  const leidasGuardadas = JSON.parse(localStorage.getItem('alertasLeidas') || '[]');
  // Aplicar a las alertas generadas
}, []);
```

CORRECCIÓN DEFINITIVA:
Solicitar al backend endpoint: POST /api/alertas/marcar-leida
Y endpoint: GET /api/alertas/usuario para obtener alertas persistidas.

================================================================================
3. TAREAS MARCADAS NO PERSISTEN
================================================================================

PROBLEMA:
El checkbox de tareas en MisTareasClient.tsx es solo visual y se pierde
al recargar.

CORRECCIÓN:
Similar a las alertas, usar localStorage como solución temporal:
```typescript
const TAREAS_MARCADAS_KEY = 'tareasMarcadasResponsable';

const cargarTareasMarcadas = () => {
  return JSON.parse(localStorage.getItem(TAREAS_MARCADAS_KEY) || '[]');
};

const guardarTareasMarcadas = (tareas: string[]) => {
  localStorage.setItem(TAREAS_MARCADAS_KEY, JSON.stringify(tareas));
};
```

================================================================================
4. PAGINACIÓN INEFICIENTE
================================================================================

PROBLEMA:
El frontend solicita hasta 1000 registros y luego pagina localmente.
Esto es ineficiente y puede causar problemas de rendimiento.

VISTAS AFECTADAS:
- ResponsableDashboardClient.tsx: size=1000
- MisReportesClient.tsx: size=1000
- CalendarioClient.tsx: size=1000
- CalendarioResponsableClient.tsx: size=1000
- AlertasClient.tsx: size=1000

CORRECCIÓN:
Implementar paginación real hacia el backend:
```typescript
// ANTES
const { data } = await flujoReportesService.misPeriodos(0, 1000);

// DESPUÉS
const [page, setPage] = useState(0);
const pageSize = 20;
const { data, totalPages } = await flujoReportesService.misPeriodos(page, pageSize);

// Y manejar cambios de página con el backend
const handlePageChange = (newPage: number) => {
  setPage(newPage);
  // El useEffect debería recargar los datos
};
```

================================================================================
5. FILTROS NO SE ENVÍAN AL BACKEND
================================================================================

PROBLEMA:
Los filtros (pendientes, enviados, vencidos, etc.) se aplican en frontend
después de traer todos los datos. Esto es ineficiente.

CORRECCIÓN:
Enviar filtros como parámetros al backend:
```typescript
// ANTES
const { data } = await flujoReportesService.misPeriodos(0, 1000);
const filtrados = data.filter(p => p.estado === 'pendiente');

// DESPUÉS
const { data } = await flujoReportesService.misPeriodos(0, 20, {
  estado: 'pendiente',
  // otros filtros
});
```

Verificar que el backend soporte estos parámetros de filtrado.

================================================================================
6. MANEJO DE FECHAS INCONSISTENTE
================================================================================

PROBLEMA:
Se calculan días restantes comparando fechas directamente, sin considerar
zonas horarias o normalización.

CORRECCIÓN:
Usar una librería de fechas o normalizar:
```typescript
// Función centralizada para cálculo de días
const calcularDiasRestantes = (fechaVencimiento: string): number => {
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0); // Normalizar a inicio del día
  
  const vencimiento = new Date(fechaVencimiento);
  vencimiento.setHours(0, 0, 0, 0);
  
  return Math.ceil((vencimiento.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
};
```

================================================================================
7. FALTA MANEJO DE ERRORES CONSISTENTE
================================================================================

PROBLEMA:
No se documenta manejo de errores cuando los endpoints fallan.

CORRECCIÓN:
Implementar try-catch con feedback al usuario:
```typescript
try {
  const { data } = await flujoReportesService.misPeriodos(0, 100);
  setPeriodos(data);
} catch (error) {
  toast.error('Error al cargar los reportes. Intente nuevamente.');
  console.error('Error:', error);
}
```

================================================================================
8. ESTADO "en_revision" NO SE MANEJA CORRECTAMENTE
================================================================================

PROBLEMA:
El estado "en_revision" se lista pero no se clasifica en ninguna categoría
de los filtros (pendientes, enviados, etc.).

CORRECCIÓN:
Incluir "en_revision" en la clasificación de enviados:
```typescript
const esEnviado = (estado: string) => {
  const e = estado?.toLowerCase();
  return ['enviado_a_tiempo', 'enviado_tarde', 'aprobado', 'en_revision'].includes(e);
};
```

================================================================================
9. EVENTOS DE CALENDARIO DUPLICADOS
================================================================================

PROBLEMA:
En CalendarioClient.tsx se generan hasta 3 eventos por periodo (vencimiento,
envío, aprobación). Esto puede saturar la vista de calendario.

CORRECCIÓN:
Considerar mostrar solo el evento más relevante según el estado:
```typescript
const generarEvento = (periodo: ReportePeriodo) => {
  if (periodo.estado === 'aprobado') {
    return { tipo: 'aprobado', fecha: periodo.updatedAt };
  } else if (['enviado_a_tiempo', 'enviado_tarde'].includes(periodo.estado)) {
    return { tipo: 'enviado', fecha: periodo.fechaEnvioReal || periodo.updatedAt };
  } else {
    return { tipo: 'vencimiento', fecha: periodo.fechaVencimientoCalculada };
  }
};
```

================================================================================
10. RESPONSIVE Y ACCESIBILIDAD (REVISAR)
================================================================================

PROBLEMA:
No se documenta si las vistas son responsive o accesibles.

CORRECCIÓN:
- Verificar que los componentes tengan atributos aria-*
- Verificar que funcionen en móviles
- Agregar loading states mientras se cargan datos

================================================================================
RESUMEN DE PRIORIDADES
================================================================================

CRÍTICO (corregir inmediatamente):
1. Inconsistencia de estados mayúsculas/minúsculas
2. Estado "en_revision" sin clasificar

ALTO (corregir pronto):
3. Manejo de errores consistente
4. Cálculo de fechas con normalización

MEDIO (mejora de rendimiento):
5. Paginación real hacia backend
6. Filtros enviados al backend

BAJO (mejoras de UX):
7. Persistir alertas leídas (localStorage temporal)
8. Persistir tareas marcadas (localStorage temporal)
9. Eventos de calendario sin duplicar
10. Revisar responsive/accesibilidad

================================================================================
FIN DE CORRECCIONES RECOMENDADASa
================================================================================